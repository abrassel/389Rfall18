Writeup 10 - Crypto II
=====

Name: Alex Brassel
Section: 0401

I pledge on my honor that I have not given or received anyunauthorized assistance on this assignment or examination.

Digital acknowledgement of honor pledge: Alexander Brassel

## Assignment 10 Writeup

### Part 1 (70 Pts)

Unfortunately, I was unable to generate a working payload.  However, I wrote a pretty comprehensive program to attempt to do so.

First, it sends a message to the notary and gets back a legitimate hash.  Then, using stub, it initiaizes the state of a local md5 to match the notary's state on the remote server.  After it does that, it updates the payload with our malicious message, finds the hash that we expect the notary to give back, and stores it as the fake_hash.

Next, I try to duplicate the message that would match that hash the notary is looking for.  I do this by sending message + padding + payload to the notary, where padding forces the entire packet sent to be 512 bits long (once the server secret is appended).  This works because it matches the state that the server has.

The padding is 0x80 (which is 1 in little endian order to mark the end of the message) followed by the appropriate number of 0's, and then finally the length of the entire message (in this case 0x20 for 32 bits).

I then iterate through possible lengths until one works.


### Part 2 (30 Pts)

In order to generate keys, one may use the command gpg --gen-key or gpg --export --armor you@email.com > pubkey.asc.  These will generate keys the public/private keypair that you will need in order to do asymmetric crypto. 

In order to import someone else's key, you should use gpg --import pubkey.asc, and for encrypting a message so that recipient can read it, you should encrypt the message with their public key using gpg -e -u "your name" -r "their key name" msg.txt.

I accomplished this part by a) importing the public key given, b) generating a message, and then c) encrypting and renaming the file generated by the gpg- e -u command.